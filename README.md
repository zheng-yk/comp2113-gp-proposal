## COMP2113 Group Project (Group 136)
### Team Members: 
- Liu Yiming, UID: 3035637539
- Zheng Yike, UID: 3035637541

### Game Description:
Name: Gomoku
Description: Gomoku is a board game with 2 players. It is usually played with Go pieces (black and white chess) on a 15×15 Go board.
Rule: There are two modes: Man-Man Mode and Man-Machine Mode. The two players use **asterisk ('*') and circle ('o')** signs respectively. They place one piece each turn by typing the coordinates of cells alternatively. For each round, the player could choose to 
1) place a piece, or 
2) recall the last step (trace back to the previous state of the board)
*Notice: this function is only applicable in the Man-Man Mode and consecutive recalling is not allowed   

The order of the two players is determined by the computer randomly. The first player uses asterisk ('*') signs and the second player uses circle ('o')  signs. Every sign should be placed at one empty cell (‘~’) of the board. Anyone who first forms 5 same signs in a row horizontally (-) / vertically (|) / left-obliquely (\) / right-obliquely (∕) will be the winner and the game is terminated.

### Implemented Features
1. Generation of random game sets or events
- Interpretation: In the Man-AI mode, we use random functions to determine the playing order of the two players That is, who would play first (holding black pieces) and who would play next (holding white pieces) is randomly generated by the program.
- Codes:
    ```c++
    resultdisplay.display("The order is random. Press any key to start: ");
    char start;
    cin.clear();
    cin.sync();
    cin>>start;
    srand(time(0));
    int rdm=rand()%2;
    //assign the first player
    first = rdm; //if rdm=1, you play first
    ```

2. Data structures for storing game status
- Interpretation: We use class to store the information of each piece on the board containing the position of row, column and type. We use the new piece sign **(‘#’ for the black player and ‘%’ for the white player)** to indicate the most recent piece placed by either player.

- Codes:
```c++
class Chess
{
private:
	int color;//
	int row;//
	int column;//

public:
	Chess(int color, int row, int column)
	{
		this->color = color;
		this->row = row;
		this->column = column;
	}
	int getColor();
	void getPosition(int &row, int &column);
	void setcolor(int color);
	void setPosition(int row, int column);
};
```

3. Dynamic memory management
- Interpretation: In man-man mode, we will ask the player if he/she would like to recal one step. If player presses 'y', the previous movement by this player and the following movement by the opponent will be recalled. The chessboard will trace back to the status of the previous round. 
We realize dynamic memory management by calling the functions **'chesspad.traceSteps(head)''newStep(Trace * & head, row, column)''deleteStep(Trace * after)'** in which we adapt chain list to capture and update the features of the pieces, including their colors, positions and orders. There are 3 nodes in this chain list. When a new piece is placed, we delete the very first nodes and append the newly added one. When recal function is trigered, we reset the 2nd and 3rd nodes' infos to empty and refresh the chessboard as the 1st node's status.
- Codes:
```c++
Trace * head = NULL;
void newStep(Trace * & head, int row, int column)
{
    Trace * new_step = new Trace;
	new_step->row = row;
	new_step->column = column;
	new_step->next = head;
	head = new_step;
}

void deleteStep(Trace * after)
{
    Trace * p = after->next;
    after->next = p->next;
    delete p;
}
```

4. File input/output (e.g., for loading/saving game status)
- Interpretation: If legal coordinates are inputted or recalled, we refresh and display the updated chessboard by adding the coordinates into the class containing current board information. (As shown in requirements 2&3)
- Codes: 
```c++
void Show::display(const int chessboard_state[15][15], string msg)
{
	system("clear");//clear screen
    cout << "     A";
    for (int i=0;i<14;i++){
        char j;
        j = 'B'+i;
        cout << "   " << j;
    }
    cout << endl;
    //print the chessboard out. represent every cell as "~"
    for (int h=0;h<14;h++)
    {
        char j;
        j = 'A'+h;
        cout <<setw(3)<<setiosflags(ios::left)<< j << "  ";
        for (int l=0;l<15;l++)
        {
            switch(chessboard_state[h][l])
            {
                case 0: // blank space
                    cout << blank<<"   ";
                    break;
                case 1://black chess
                    cout << black<<"   ";
                    break;
                case 2://white chess
                    cout << white<<"   ";
                    break;
                case 3://the last black chess
                    cout << black_last<<"   ";
                    break;
                case 4://the last white chess
                    cout << white_last<<"   ";
                    break;
            }
        }
        cout << endl;
    }


	cout << msg;
}
```

5. Program codes in multiple files
- We include multiple files (.cpp and .h) to realize the game, which are interconnected and can be called by each other. 

6. Proper indentation and naming styles
- Interpretation: We adopt proper indentation and naming methods to illustrate the codes in a readable way. For example, ‘Show::display’ function is used to update and display the chessboard, with understandable variable names as ‘blank’ ‘black’, ‘white’, which represent ‘empty cell’ ‘a cell that is occupied by black piece’ ‘a cell that is occupied by white piece’, respectively.
- Codes:
```c++
class Show{
private:
	string blank;
	string black;
	string white;
	string black_last;
	string white_last;

public:
	Show()
	{
		blank = "~";
		black = "*";
		white = "o";
		black_last = "-";
		white_last = "+";
	}
	void display(const int chesspadstate[15][15], std::string msg);//clear board and display
	void display(std::string msg);//initial display

};
```
 
7. In-code documentation
- Interpretation: our codes is well-explained using detailed documentation, every function is accompanied by comments on “what it does”, “what the inputs are” and “what the outputs are”.
- Codes:
```c++
for (int i = position.x, j = 1;j <= 4;j++) {//copy 4 units in the left
            int column = position.y - j;
            if (column < 0) {
                for (;j <= 4;j++)
                    chess[4 - j] = hiscolor;//out of the border: set opponent's color
                break;
            }
            chess[4 - j] = state[i][column];//within the border: copy array "state"
        }
        for (int i = position.x, j = 1;j <= 4;j++) {//copy 4 units in the right
            int column = position.y + j;
            if (column > 14) {
                for (;j <= 4;j++)
                    chess[4 + j] = hiscolor;//out of the border: set opponent's color
                break;
            }
            chess[4 + j] = state[i][column];//within the border: copy array "state"
        }
        break;
```

### Compilation and execution instructions
Compilation:
- Makefile can realize the compilation progress and generate an executable document.
In linux environment, input:
```
$ make main
```
to get the executable file.
- Makefile:
```
FLAGS = -pedantic-errors -std=c++11

AI.o: AI.cpp AI.h
	g++ $(FLAGS) -c $<

AIplayer.o: AIplayer.cpp AIplayer.h
	g++ $(FLAGS) -c $<

Board.o: Board.cpp Board.h chess.h
	g++ $(FLAGS) -c $<

chess.o: chess.cpp chess.h
	g++ $(FLAGS) -c $<

player.o: player.cpp player.h
	g++ $(FLAGS) -c $<

Game.o: Game.cpp Game.h
	g++ $(FLAGS) -c $<

Judge.o: Judge.cpp Judge.h
	g++ $(FLAGS) -c $<

PersonPlayer.o: PersonPlayer.cpp PersonPlayer.h
	g++ $(FLAGS) -c $<

show.o: show.cpp show.h
	g++ $(FLAGS) -c $<

main.o: main.cpp Game.h
	g++ $(FLAGS) -c $<

Trace.o: Trace.cpp Trace.h
	g++ $(FLAGS) -c $<

main: AI.o AIplayer.o Board.o chess.o player.o Game.o Judge.o PersonPlayer.o show.o Trace.o main.o
	g++ $(FLAGS) $^ -o $@

clean:
	rm -f main AI.o AIplayer.o Board.o chess.o player.o Game.o Judge.o Trace.o PersonPlayer.o show.o main.o main.tgz

tar:
	tar -czvf main.tgz *.cpp *.h

.PHONY: clean 
```

Execution:
- Choose mode: type ‘0’ to choose Man-Machine Mode or type ‘1’ to choose Man-Man Mode. Press ‘Enter’ to continue.
- Man-Machine Mode
1. Press any button then ‘Enter’ to see the randomly assigned play order.
2. Enter your coordinates, following the format of [vertical coordinate] [horizontal coordinate]
3. AI will calculate and outperform the optimal movement, enter your next coordinates and continue the game.
4. End of the game: the first one to form a 5-in-a-row situation wins the game. Press ‘e’ to quit.  
- Man-Man Mode
1. Blackplayer goes first. Press 'y' to recall the previous movement. Press 'n' to continue. 
2. Enter your coordinates, following the format of [vertical coordinate] [horizontal coordinate]
3. Whiteplayer goes next. Press 'y' to recall the previous movement. Press 'n' to continue. 
4. Enter your coordinates, following the format of [vertical coordinate] [horizontal coordinate]
5. End of the game: the first one to form a 5-in-a-row situation wins the game. Press ‘e’ to quit.  
